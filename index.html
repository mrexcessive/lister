<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Multi-List App</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      max-width: 400px;
      margin: 20px auto;
      text-align: center;
      padding: 10px;
      position: relative;
    }
    /* Version number styling - update version number with each new patch by adding 0.001 */
    #version {
      position: absolute;
      top: 10px;
      right: 10px;
      font-size: 10px;
      color: #888;
    }
    /* Menu styles */
    #menu {
      position: absolute;
      top: 10px;
      left: 10px;
      font-size: 24px;
      cursor: pointer;
      user-select: none;
      -webkit-user-select: none;
    }
    #menuDropdown {
      display: none;
      position: absolute;
      left: 10px;
      top: 40px;
      background: white;
      border: 1px solid #ccc;
      padding: 10px;
      width: 200px;
      z-index: 100;
    }
    input[type="text"] {
      width: 80%;
      padding: 10px;
      font-size: 16px;
      border: 1px solid #ccc;
      margin-bottom: 10px;
    }
    button {
      padding: 8px 12px;
      margin: 5px;
      font-size: 16px;
      cursor: pointer;
    }
    ul {
      list-style: none;
      padding: 0;
      margin: 0;
    }
    /* List items: disable text selection and default touch actions */
    li {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 8px;
      border-bottom: 1px solid #ddd;
      cursor: grab;
      text-align: left;
      word-break: break-word;
      background: #fff;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
      touch-action: none;
    }
    li.dragging {
      opacity: 0.5;
      background: #f0f0f0;
    }
    /* Container for checkbox and text label */
    .item-content {
      display: flex;
      align-items: center;
      flex: 1;
    }
    /* Minimal width for checkbox */
    li input[type="checkbox"] {
      flex: 0 0 auto;
      margin: 0;
      padding: 0;
    }
    /* Item text occupies remaining space */
    .item-text {
      flex: 1;
      padding: 0 10px;
      text-align: left;
      -webkit-user-select: none;
      user-select: none;
      touch-action: none;
    }
    /* Drag handle styling: on the right with minimal width */
    .drag-handle {
      font-size: 20px;
      padding: 0 5px;
      cursor: grab;
      user-select: none;
      flex: 0 0 auto;
      margin-left: 5px;
    }
    .undo-btn {
      display: none;
      background: orange;
      color: white;
      font-size: 14px;
      border: none;
      cursor: pointer;
      padding: 5px;
      margin-top: 10px;
    }
    /* Popup for loading a list from text */
    #loadListPopup {
      display: none;
      position: fixed;
      top: 30%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: white;
      padding: 20px;
      border: 1px solid #ccc;
      z-index: 200;
    }
    textarea {
      width: 100%;
      font-size: 16px;
      padding: 10px;
      box-sizing: border-box;
    }
    h2 {
      margin: 10px 0;
      font-size: 22px;
      cursor: pointer;
      user-select: none;
      -webkit-user-select: none;
      touch-action: none;
    }
    /* Custom delete confirmation popup */
    #deleteConfirmPopup {
      display: none;
      position: fixed;
      top: 30%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: white;
      border: 1px solid #ccc;
      padding: 20px;
      z-index: 210;
    }
    #deleteConfirmPopup p {
      margin: 0;
    }
    #deleteItemText {
      font-size: 10px;
      color: #666;
      margin: 5px 0 10px;
    }
    /* Increase scrollbar sensitive area (WebKit only) */
    ::-webkit-scrollbar {
      width: 32px; /* Twice the normal width (assuming default is ~16px) */
    }
  </style>
</head>
<body onclick="closeMenu(event)">
  <div id="menu" onclick="toggleMenu(event)">☰</div>
  <div id="version">0.003</div> <!-- Updated version number -->
  <div id="menuDropdown">
    <button onclick="newList()">+ New List</button>
    <button onclick="showLoadListPopup()">+ Load List</button>
    <button onclick="clearAllCheckboxes()">Clear Checkboxes</button>
    <div id="listSelector"></div>
  </div>

  <h2 id="listTitle">My List</h2>
  <input type="text" id="itemInput" placeholder="Add new item..." />
  <button onclick="addItem()">Add</button>
  <ul id="itemList"></ul>
  <button id="undoBtn" class="undo-btn" onclick="undoClearCheckboxes()">Undo</button>

  <div id="loadListPopup">
    <textarea id="loadListInput" placeholder="Paste list here (one item per line)" rows="5"></textarea><br>
    <button onclick="loadListFromText()">Load</button>
    <button onclick="hideLoadListPopup()">Cancel</button>
  </div>
  
  <!-- Custom Delete Confirmation Popup -->
  <div id="deleteConfirmPopup">
    <p id="deleteConfirmText" style="font-weight: bold;">Delete this item?</p>
    <p id="deleteItemText"></p>
    <button onclick="confirmDelete(true)">Delete</button>
    <button onclick="confirmDelete(false)">Cancel</button>
  </div>

  <script>
    let currentList = localStorage.getItem("currentList") || "Default List";
    let previousCheckboxState = null;
    let listDeleteTimer = null;
    let itemDeleteTimer = null;
    // Mobile drag variables (for drag-handle only)
    let mobileDragTimer = null;
    let mobileDraggingIndex = null;
    // For drag placeholder (the "shadow")
    let dropPlaceholderEl = null;
    // Pending delete index for custom delete popup
    let pendingDeleteIndex = null;

    // Initialize title, lists, and items
    document.getElementById("listTitle").innerText = currentList;
    loadLists();
    renderItems();

    // Add item on Enter key
    document.getElementById("itemInput").addEventListener("keypress", function (event) {
      if (event.key === "Enter") {
        event.preventDefault();
        addItem();
      }
    });

    // ---------------------------
    // Menu and List management
    // ---------------------------
    function toggleMenu(event) {
      event.stopPropagation();
      const menu = document.getElementById("menuDropdown");
      menu.style.display = (menu.style.display === "block") ? "none" : "block";
    }
    function closeMenu(event) {
      const menu = document.getElementById("menuDropdown");
      if (!event.target.closest("#menuDropdown") && !event.target.closest("#menu")) {
        menu.style.display = "none";
      }
    }
    function newList() {
      const name = prompt("Enter new list name:");
      if (name && !getLists().includes(name)) {
        const lists = getLists();
        lists.push(name);
        saveLists(lists);
        switchList(name);
      }
    }
    function showLoadListPopup() {
      document.getElementById("loadListPopup").style.display = "block";
    }
    function hideLoadListPopup() {
      document.getElementById("loadListPopup").style.display = "none";
    }
    function loadListFromText() {
      const text = document.getElementById("loadListInput").value;
      if (text) {
        // Split lines, trim, and ignore blank lines
        const items = text.split("\n")
          .map(line => line.trim())
          .filter(line => line.length > 0)
          .map(line => ({ text: line, checked: false }));
        saveItems(items);
        renderItems();
      }
      hideLoadListPopup();
    }
    function switchList(name) {
      currentList = name;
      localStorage.setItem("currentList", name);
      document.getElementById("listTitle").innerText = name;
      renderItems();
      loadLists();
    }
    function editListName() {
      const title = document.getElementById("listTitle");
      const newName = prompt("Enter new list name:", title.innerText.trim());
      if (newName && newName !== title.innerText) {
        let lists = getLists();
        const index = lists.indexOf(currentList);
        if (index !== -1) {
          lists[index] = newName;
          saveLists(lists);
          // Migrate stored items to new key
          localStorage.setItem(`items_${newName}`, localStorage.getItem(`items_${currentList}`));
          localStorage.removeItem(`items_${currentList}`);
          switchList(newName);
        }
      }
    }
    function deleteList() {
      const confirmation = prompt(`Type 'confirm' to delete the list "${currentList}":`);
      if (confirmation === "confirm") {
        let lists = getLists().filter(l => l !== currentList);
        saveLists(lists);
        localStorage.removeItem(`items_${currentList}`);
        currentList = lists.length > 0 ? lists[0] : "Default List";
        localStorage.setItem("currentList", currentList);
        document.getElementById("listTitle").innerText = currentList;
        renderItems();
        loadLists();
      } else {
        alert("List deletion cancelled.");
      }
    }
    function startListDeleteTimer() {
      listDeleteTimer = setTimeout(() => {
        deleteList();
      }, 3000);
    }
    function cancelListDeleteTimer() {
      clearTimeout(listDeleteTimer);
    }
    function clearAllCheckboxes() {
      if (!confirm("Are you sure you want to clear all checkboxes?")) return;
      previousCheckboxState = getItems().map(item => ({ ...item }));
      const items = getItems().map(item => ({ ...item, checked: false }));
      saveItems(items);
      renderItems();
      document.getElementById("undoBtn").style.display = "block";
    }
    function undoClearCheckboxes() {
      if (previousCheckboxState) {
        saveItems(previousCheckboxState);
        renderItems();
        document.getElementById("undoBtn").style.display = "none";
        previousCheckboxState = null;
      }
    }
    function getLists() {
      return JSON.parse(localStorage.getItem("lists")) || ["Default List"];
    }
    function saveLists(lists) {
      localStorage.setItem("lists", JSON.stringify(lists));
    }
    function loadLists() {
      const listSelector = document.getElementById("listSelector");
      listSelector.innerHTML = "";
      getLists().forEach(name => {
        const btn = document.createElement("button");
        btn.textContent = name;
        btn.style.display = "block";
        btn.onclick = () => switchList(name);
        listSelector.appendChild(btn);
      });
    }

    // ---------------------------
    // Item management functions
    // ---------------------------
    function addItem() {
      const input = document.getElementById("itemInput");
      const text = input.value.trim();
      if (text === "") return;
      const items = getItems();
      items.push({ text, checked: false });
      saveItems(items);
      input.value = "";
      renderItems();
    }
    function getItems() {
      return JSON.parse(localStorage.getItem(`items_${currentList}`)) || [];
    }
    function saveItems(items) {
      localStorage.setItem(`items_${currentList}`, JSON.stringify(items));
    }
    function toggleItem(index) {
      const items = getItems();
      items[index].checked = !items[index].checked;
      saveItems(items);
      renderItems();
    }
    function editItem(index) {
      const items = getItems();
      const newText = prompt("Edit item:", items[index].text);
      if (newText !== null && newText.trim() !== "") {
        items[index].text = newText.trim();
        saveItems(items);
        renderItems();
      }
    }
    // Use custom delete confirmation instead of native confirm.
    function showDeleteConfirm(index) {
      pendingDeleteIndex = index;
      const items = getItems();
      const itemText = items[index].text;
      document.getElementById("deleteConfirmText").innerText = "Delete this item?";
      document.getElementById("deleteItemText").innerText = itemText;
      document.getElementById("deleteConfirmPopup").style.display = "block";
    }
    function confirmDelete(confirmed) {
      if (confirmed && pendingDeleteIndex !== null) {
         const items = getItems();
         items.splice(pendingDeleteIndex, 1);
         saveItems(items);
         renderItems();
      }
      pendingDeleteIndex = null;
      document.getElementById("deleteConfirmPopup").style.display = "none";
    }
    // ---------------------------
    // Drag-and-drop (Desktop)
    // ---------------------------
    let draggedIndex = null;
    function handleDragStart(e, index) {
      draggedIndex = index;
      e.target.classList.add("dragging");
    }
    function handleDragOver(e) {
      e.preventDefault();
    }
    function handleDrop(e, dropIndex) {
      e.preventDefault();
      if (draggedIndex === null) return;
      const items = getItems();
      const [movedItem] = items.splice(draggedIndex, 1);
      items.splice(dropIndex, 0, movedItem);
      saveItems(items);
      renderItems();
      draggedIndex = null;
    }
    function handleDragEnd(e) {
      e.target.classList.remove("dragging");
      draggedIndex = null;
    }

    // ---------------------------
    // Mobile Drag-and-drop (via drag-handle)
    // ---------------------------
    // Updated to include flick-to-delete and a drag placeholder (shadow) showing the current insert point.
    function handleDragTouchStart(e, index) {
      // Start drag after a short delay (500ms)
      mobileDragTimer = setTimeout(() => {
        mobileDraggingIndex = index;
        e.currentTarget.parentElement.classList.add("dragging");
      }, 500);
      // Record initial touch coordinates and time for flick detection
      e.currentTarget.dataset.startX = e.touches[0].clientX;
      e.currentTarget.dataset.startY = e.touches[0].clientY;
      e.currentTarget.dataset.touchStartTime = Date.now();
    }
    function handleDragTouchEnd(e, index) {
      clearTimeout(mobileDragTimer);
      const touch = e.changedTouches[0];
      const startX = parseFloat(e.currentTarget.dataset.startX);
      const touchStartTime = parseInt(e.currentTarget.dataset.touchStartTime);
      const elapsedTime = Date.now() - touchStartTime;
      const deltaX = touch.clientX - startX;
      // If a fast flick to the left is detected, show custom delete popup.
      if (deltaX < -50 && elapsedTime < 300) {
        showDeleteConfirm(index);
        if (document.getElementById("dropPlaceholder")) {
          document.getElementById("dropPlaceholder").remove();
        }
        return;
      }
      // If dragging was active, complete the drop operation.
      if (mobileDraggingIndex !== null) {
        if (document.getElementById("dropPlaceholder")) {
          document.getElementById("dropPlaceholder").remove();
        }
        // Recalculate drop index using the same logic as updateDragPlaceholder.
        let liElements = Array.from(document.querySelectorAll("#itemList li:not(.dragging):not(#dropPlaceholder)"));
        let dropIndex = liElements.length;
        for (let i = 0; i < liElements.length; i++) {
          let rect = liElements[i].getBoundingClientRect();
          if (touch.clientY < rect.top + rect.height / 2) {
            dropIndex = i;
            break;
          }
        }
        const items = getItems();
        const [movedItem] = items.splice(mobileDraggingIndex, 1);
        items.splice(dropIndex, 0, movedItem);
        saveItems(items);
        renderItems();
        mobileDraggingIndex = null;
      }
    }
    function updateDragPlaceholder(e) {
      if (mobileDraggingIndex === null) return;
      let touch = e.touches[0];
      // Determine drop index based on touch vertical position.
      let liElements = Array.from(document.querySelectorAll("#itemList li:not(.dragging):not(#dropPlaceholder)"));
      let dropIndex = liElements.length; // Default to end.
      for (let i = 0; i < liElements.length; i++) {
        let rect = liElements[i].getBoundingClientRect();
        if (touch.clientY < rect.top + rect.height / 2) {
          dropIndex = i;
          break;
        }
      }
      // Create or update drop placeholder element.
      if (!dropPlaceholderEl) {
        dropPlaceholderEl = document.createElement("li");
        dropPlaceholderEl.id = "dropPlaceholder";
        dropPlaceholderEl.style.height = "40px";
        dropPlaceholderEl.style.background = "#f9f9f9";
        dropPlaceholderEl.style.border = "2px dashed #aaa";
        dropPlaceholderEl.style.margin = "4px 0";
        dropPlaceholderEl.style.display = "flex";
        dropPlaceholderEl.style.alignItems = "center";
        dropPlaceholderEl.style.justifyContent = "center";
        dropPlaceholderEl.style.fontStyle = "italic";
      }
      const items = getItems();
      if (items[mobileDraggingIndex]) {
        dropPlaceholderEl.textContent = items[mobileDraggingIndex].text;
      }
      // Insert the placeholder into the list at the computed drop index.
      const itemList = document.getElementById("itemList");
      const existingPlaceholder = document.getElementById("dropPlaceholder");
      if (existingPlaceholder) existingPlaceholder.remove();
      if (dropIndex >= itemList.children.length) {
        itemList.appendChild(dropPlaceholderEl);
      } else {
        itemList.insertBefore(dropPlaceholderEl, itemList.children[dropIndex]);
      }
    }

    // ---------------------------
    // Render Items with Drag, Edit, Delete and Row Highlighting
    // ---------------------------
    function renderItems() {
      const itemList = document.getElementById("itemList");
      itemList.innerHTML = "";
      const items = getItems();
      items.forEach((item, index) => {
        const li = document.createElement("li");
        li.draggable = true;
        li.ondragstart = (e) => handleDragStart(e, index);
        li.ondragover = handleDragOver;
        li.ondrop = (e) => handleDrop(e, index);
        li.ondragend = handleDragEnd;
        li.style.background = item.checked ? "#d0eaff" : "#fff";

        const contentDiv = document.createElement("div");
        contentDiv.className = "item-content";
        
        const checkbox = document.createElement("input");
        checkbox.type = "checkbox";
        checkbox.checked = item.checked;
        checkbox.onclick = (e) => {
          e.stopPropagation();
          toggleItem(index);
        };

        const span = document.createElement("span");
        span.className = "item-text";
        span.textContent = item.text;
        span.addEventListener("touchend", function (e) {
          e.preventDefault();
          let currentTime = new Date().getTime();
          let lastTap = this.dataset.lastTap || 0;
          if (currentTime - lastTap < 300) {
            clearTimeout(itemDeleteTimer);
            editItem(index);
          }
          this.dataset.lastTap = currentTime;
          clearTimeout(itemDeleteTimer);
        });
        span.addEventListener("touchstart", function (e) {
          e.preventDefault();
          itemDeleteTimer = setTimeout(() => {
            showDeleteConfirm(index);
          }, 3000);
        });
        span.addEventListener("touchcancel", function (e) {
          clearTimeout(itemDeleteTimer);
        });
        span.ondblclick = (e) => {
          e.stopPropagation();
          editItem(index);
        };

        contentDiv.appendChild(checkbox);
        contentDiv.appendChild(span);
        const dragHandle = document.createElement("span");
        dragHandle.className = "drag-handle";
        dragHandle.innerText = "≡";
        dragHandle.addEventListener("touchstart", (e) => handleDragTouchStart(e, index));
        dragHandle.addEventListener("touchend", (e) => handleDragTouchEnd(e, index));
        dragHandle.addEventListener("touchmove", (e) => updateDragPlaceholder(e));
        
        li.appendChild(contentDiv);
        li.appendChild(dragHandle);
        itemList.appendChild(li);
      });
    }

    // ---------------------------
    // List title events: double-tap to edit, long-press (3 sec) to delete list
    // ---------------------------
    const listTitle = document.getElementById("listTitle");
    listTitle.addEventListener("touchend", function (e) {
      e.preventDefault();
      let currentTime = new Date().getTime();
      let lastTap = this.dataset.lastTap || 0;
      if (currentTime - lastTap < 300) {
        clearTimeout(listDeleteTimer);
        editListName();
      }
      this.dataset.lastTap = currentTime;
      clearTimeout(listDeleteTimer);
    });
    listTitle.addEventListener("touchstart", function (e) {
      e.preventDefault();
      listDeleteTimer = setTimeout(() => {
        deleteList();
      }, 3000);
    });
    listTitle.addEventListener("touchcancel", function (e) {
      clearTimeout(listDeleteTimer);
    });
    listTitle.ondblclick = (e) => {
      e.stopPropagation();
      editListName();
    };
  </script>
</body>
</html>
