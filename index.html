<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Multi-List App</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      max-width: 400px;
      margin: 20px auto;
      text-align: center;
      padding: 10px;
      position: relative;
    }
    /* Version number styling */
    #version {
      position: absolute;
      top: 10px;
      right: 10px;
      font-size: 10px;
      color: #888;
    }
    /* Menu styles */
    #menu {
      position: absolute;
      top: 10px;
      left: 10px;
      font-size: 24px;
      cursor: pointer;
      user-select: none;
      -webkit-user-select: none;
    }
    #menuDropdown {
      display: none;
      position: absolute;
      left: 10px;
      top: 40px;
      background: white;
      border: 1px solid #ccc;
      padding: 10px;
      width: 200px;
      z-index: 100;
    }
    /* Header for list title and load button */
    #listHeader {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin: 10px 0;
    }
    h2 {
      margin: 0;
      font-size: 22px;
      cursor: pointer;
      user-select: none;
      -webkit-user-select: none;
      /* Allow vertical pan for scrolling */
      touch-action: pan-y;
    }
    button {
      padding: 8px 12px;
      margin: 5px;
      font-size: 16px;
      cursor: pointer;
    }
    ul {
      list-style: none;
      padding: 0;
      margin: 0;
    }
    /* List items – allow vertical panning (for scrolling) */
    li {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 8px;
      border-bottom: 1px solid #ddd;
      cursor: grab;
      text-align: left;
      word-break: break-word;
      background: #fff;
      user-select: none;
      touch-action: pan-y;
    }
    li.dragging {
      opacity: 0.5;
      background: #f0f0f0;
    }
    /* Container for checkbox and text label */
    .item-content {
      display: flex;
      align-items: center;
      flex: 1;
    }
    /* Minimal width for checkbox */
    li input[type="checkbox"] {
      flex: 0 0 auto;
      margin: 0;
      padding: 0;
    }
    /* Item text styling */
    .item-text {
      flex: 1;
      padding: 0 10px;
      text-align: left;
      user-select: none;
      touch-action: pan-y;
    }
    /* Drag handle styling */
    .drag-handle {
      font-size: 20px;
      padding: 0 5px;
      cursor: grab;
      user-select: none;
      flex: 0 0 auto;
      margin-left: 5px;
    }
    .undo-btn {
      display: none;
      background: orange;
      color: white;
      font-size: 14px;
      border: none;
      cursor: pointer;
      padding: 5px;
      margin-top: 10px;
    }
    /* Popup for loading a list from text */
    #loadListPopup {
      display: none;
      position: fixed;
      top: 30%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: white;
      padding: 20px;
      border: 1px solid #ccc;
      z-index: 200;
    }
    textarea {
      width: 100%;
      font-size: 16px;
      padding: 10px;
      box-sizing: border-box;
    }
    /* Custom delete confirmation popup */
    #deleteConfirmPopup {
      display: none;
      position: fixed;
      top: 30%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: white;
      border: 1px solid #ccc;
      padding: 20px;
      z-index: 210;
    }
    #deleteConfirmPopup p {
      margin: 0;
    }
    #deleteItemText {
      font-size: 10px;
      color: #666;
      margin: 5px 0 10px;
    }
    /* Footer bar style */
    .footer-bar {
      background: #eee;
      text-align: center;
      padding: 8px;
      font-size: 16px;
      width: 100%;
      box-sizing: border-box;
      user-select: none;
      cursor: default;
    }
    /* Increase scrollbar sensitive area (WebKit only) */
    ::-webkit-scrollbar {
      width: 32px;
    }
  </style>
</head>
<body onclick="closeMenu(event)">
  <div id="menu" onclick="toggleMenu(event)">☰</div>
  <!-- Updated version number -->
  <div id="version">0.008</div>

  <div id="menuDropdown">
    <button onclick="newList()">+ New List</button>
    <button onclick="clearAllCheckboxes()">Clear Checkboxes</button>
    <div id="listSelector"></div>
  </div>

  <!-- Header: List title and load button -->
  <div id="listHeader">
    <h2 id="listTitle">My List</h2>
    <button id="loadBtn" onclick="showLoadListPopup()">load</button>
  </div>

  <!-- The add-item input has been removed; new items are added by flicking right -->
  <ul id="itemList"></ul>
  <button id="undoBtn" class="undo-btn" onclick="undoClearCheckboxes()">Undo</button>

  <div id="loadListPopup">
    <textarea id="loadListInput" placeholder="Paste list here (one item per line)" rows="5"></textarea><br>
    <button onclick="loadListFromText()">Load</button>
    <button onclick="hideLoadListPopup()">Cancel</button>
  </div>
  
  <!-- Custom Delete Confirmation Popup -->
  <div id="deleteConfirmPopup">
    <p id="deleteConfirmText" style="font-weight: bold;">Delete this item?</p>
    <p id="deleteItemText"></p>
    <button onclick="confirmDelete(true)">Delete</button>
    <button onclick="confirmDelete(false)">Cancel</button>
  </div>

  <script>
    // Global variables
    let currentList = localStorage.getItem("currentList") || "Default List";
    let previousCheckboxState = null;
    let listDeleteTimer = null;
    let itemDeleteTimer = null;
    let mobileDragTimer = null;
    let mobileDraggingIndex = null;
    let dropPlaceholderEl = null;
    let pendingDeleteIndex = null;
    // To ensure only one editing field is active at any time.
    let currentEditingInput = null;

    // Initialize title, lists, and items
    document.getElementById("listTitle").innerText = currentList;
    loadLists();
    renderItems();

    // ---------------------------
    // Menu and List management
    // ---------------------------
    function toggleMenu(event) {
      event.stopPropagation();
      const menu = document.getElementById("menuDropdown");
      menu.style.display = (menu.style.display === "block") ? "none" : "block";
    }
    function closeMenu(event) {
      const menu = document.getElementById("menuDropdown");
      if (!event.target.closest("#menuDropdown") && !event.target.closest("#menu")) {
        menu.style.display = "none";
      }
    }
    function newList() {
      const name = prompt("Enter new list name:");
      if (name && !getLists().includes(name)) {
        const lists = getLists();
        lists.push(name);
        saveLists(lists);
        switchList(name);
      }
    }
    function showLoadListPopup() {
      document.getElementById("loadListPopup").style.display = "block";
    }
    function hideLoadListPopup() {
      document.getElementById("loadListPopup").style.display = "none";
    }
    function loadListFromText() {
      const text = document.getElementById("loadListInput").value;
      if (text) {
        const items = text.split("\n")
          .map(line => line.trim())
          .filter(line => line.length > 0)
          .map(line => ({ text: line, checked: false }));
        saveItems(items);
        renderItems();
      }
      hideLoadListPopup();
    }
    function switchList(name) {
      currentList = name;
      localStorage.setItem("currentList", name);
      document.getElementById("listTitle").innerText = name;
      renderItems();
      loadLists();
    }
    // In-place editing for the list title.
    function editListTitle() {
      if (currentEditingInput) currentEditingInput.blur();
      const listTitleElement = document.getElementById("listTitle");
      const originalTitle = listTitleElement.innerText;
      const input = document.createElement("input");
      input.type = "text";
      input.value = originalTitle;
      input.style.fontSize = "22px";
      input.style.textAlign = "center";
      input.onkeydown = function(e) {
        if (e.key === "Enter") {
          input.blur();
        }
      };
      input.onblur = function() {
        const newTitle = input.value.trim();
        if (newTitle === "") {
          listTitleElement.innerText = originalTitle;
        } else {
          listTitleElement.innerText = newTitle;
          if (newTitle !== originalTitle) {
            let lists = getLists();
            const idx = lists.indexOf(originalTitle);
            if (idx !== -1) {
              lists[idx] = newTitle;
              saveLists(lists);
              // Migrate stored items if needed.
              localStorage.setItem(`items_${newTitle}`, localStorage.getItem(`items_${originalTitle}`));
              localStorage.removeItem(`items_${originalTitle}`);
            }
            currentList = newTitle;
            localStorage.setItem("currentList", newTitle);
          }
        }
        document.getElementById("listHeader").replaceChild(listTitleElement, input);
        currentEditingInput = null;
      };
      currentEditingInput = input;
      document.getElementById("listHeader").replaceChild(input, listTitleElement);
      input.focus();
    }
    // Replace the old prompt-based edit with in-place editing.
    function editListName() {
      editListTitle();
    }
    function deleteList() {
      const confirmation = prompt(`Type 'confirm' to delete the list "${currentList}":`);
      if (confirmation === "confirm") {
        let lists = getLists().filter(l => l !== currentList);
        saveLists(lists);
        localStorage.removeItem(`items_${currentList}`);
        currentList = lists.length > 0 ? lists[0] : "Default List";
        localStorage.setItem("currentList", currentList);
        document.getElementById("listTitle").innerText = currentList;
        renderItems();
        loadLists();
      } else {
        alert("List deletion cancelled.");
      }
    }
    function startListDeleteTimer() {
      listDeleteTimer = setTimeout(() => {
        deleteList();
      }, 3000);
    }
    function cancelListDeleteTimer() {
      clearTimeout(listDeleteTimer);
    }
    function clearAllCheckboxes() {
      if (!confirm("Are you sure you want to clear all checkboxes?")) return;
      previousCheckboxState = getItems().map(item => ({ ...item }));
      const items = getItems().map(item => ({ ...item, checked: false }));
      saveItems(items);
      renderItems();
      document.getElementById("undoBtn").style.display = "block";
    }
    function undoClearCheckboxes() {
      if (previousCheckboxState) {
        saveItems(previousCheckboxState);
        renderItems();
        document.getElementById("undoBtn").style.display = "none";
        previousCheckboxState = null;
      }
    }
    function getLists() {
      return JSON.parse(localStorage.getItem("lists")) || ["Default List"];
    }
    function saveLists(lists) {
      localStorage.setItem("lists", JSON.stringify(lists));
    }
    function loadLists() {
      const listSelector = document.getElementById("listSelector");
      listSelector.innerHTML = "";
      getLists().forEach(name => {
        const btn = document.createElement("button");
        btn.textContent = name;
        btn.style.display = "block";
        btn.onclick = () => switchList(name);
        listSelector.appendChild(btn);
      });
    }

    // ---------------------------
    // Item management functions
    // ---------------------------
    function getItems() {
      return JSON.parse(localStorage.getItem(`items_${currentList}`)) || [];
    }
    function saveItems(items) {
      localStorage.setItem(`items_${currentList}`, JSON.stringify(items));
    }
    function toggleItem(index) {
      const items = getItems();
      items[index].checked = !items[index].checked;
      saveItems(items);
      renderItems();
    }
    // In-place editing for an item.
    function editItem(index, labelElement) {
      if (currentEditingInput) currentEditingInput.blur();
      const items = getItems();
      const originalText = items[index].text;
      // Instead of replacing from li, replace from the label's parent.
      const input = document.createElement("input");
      input.type = "text";
      input.value = originalText;
      input.style.flex = "1";
      input.onkeydown = function(e) {
        if (e.key === "Enter") {
          input.blur();
        }
      };
      input.onblur = function() {
        const newText = input.value.trim();
        if (newText === "") {
          // If originally empty, remove the item; otherwise, revert.
          if (originalText === "") {
            items.splice(index, 1);
          } else {
            items[index].text = originalText;
          }
        } else {
          items[index].text = newText;
        }
        saveItems(items);
        renderItems();
        currentEditingInput = null;
      };
      currentEditingInput = input;
      // Fix: replace the label within its parent rather than from li directly.
      labelElement.parentElement.replaceChild(input, labelElement);
      input.focus();
    }
    function showDeleteConfirm(index) {
      pendingDeleteIndex = index;
      const items = getItems();
      const itemText = items[index].text;
      document.getElementById("deleteConfirmText").innerText = "Delete this item?";
      document.getElementById("deleteItemText").innerText = itemText;
      document.getElementById("deleteConfirmPopup").style.display = "block";
    }
    function confirmDelete(confirmed) {
      if (confirmed && pendingDeleteIndex !== null) {
         const items = getItems();
         items.splice(pendingDeleteIndex, 1);
         saveItems(items);
         renderItems();
      }
      pendingDeleteIndex = null;
      document.getElementById("deleteConfirmPopup").style.display = "none";
    }
    // Insert a new (empty) item at the given index and immediately start editing it.
    function insertNewItem(index) {
      let items = getItems();
      items.splice(index, 0, { text: "", checked: false });
      saveItems(items);
      renderItems();
      setTimeout(() => {
        const itemList = document.getElementById("itemList");
        if (itemList.children[index]) {
          const newLabel = itemList.children[index].querySelector(".item-text");
          if (newLabel) {
            editItem(index, newLabel);
          }
        }
      }, 0);
    }

    // ---------------------------
    // Drag-and-drop (Desktop) – unchanged.
    // ---------------------------
    let draggedIndex = null;
    function handleDragStart(e, index) {
      draggedIndex = index;
      e.target.classList.add("dragging");
    }
    function handleDragOver(e) {
      e.preventDefault();
    }
    function handleDrop(e, dropIndex) {
      e.preventDefault();
      if (draggedIndex === null) return;
      const items = getItems();
      const [movedItem] = items.splice(draggedIndex, 1);
      items.splice(dropIndex, 0, movedItem);
      saveItems(items);
      renderItems();
      draggedIndex = null;
    }
    function handleDragEnd(e) {
      e.target.classList.remove("dragging");
      draggedIndex = null;
    }

    // ---------------------------
    // Mobile Drag-and-drop and flick detection (via drag-handle)
    // ---------------------------
    function handleDragTouchStart(e, index) {
      mobileDragTimer = setTimeout(() => {
        mobileDraggingIndex = index;
        e.currentTarget.parentElement.classList.add("dragging");
      }, 500);
      e.currentTarget.dataset.startX = e.touches[0].clientX;
      e.currentTarget.dataset.startY = e.touches[0].clientY;
      e.currentTarget.dataset.touchStartTime = Date.now();
    }
    function handleDragTouchEnd(e, index) {
      clearTimeout(mobileDragTimer);
      const touch = e.changedTouches[0];
      const startX = parseFloat(e.currentTarget.dataset.startX);
      const touchStartTime = parseInt(e.currentTarget.dataset.touchStartTime);
      const elapsedTime = Date.now() - touchStartTime;
      const deltaX = touch.clientX - startX;
      // Flick left anywhere on the row: trigger delete.
      if (deltaX < -50 && elapsedTime < 300) {
        showDeleteConfirm(index);
        if (document.getElementById("dropPlaceholder")) {
          document.getElementById("dropPlaceholder").remove();
        }
        return;
      }
      // Flick right on the handle: insert new item after this row.
      if (deltaX > 50 && elapsedTime < 300) {
        insertNewItem(index + 1);
        return;
      }
      // If dragging was active, complete drop.
      if (mobileDraggingIndex !== null) {
        if (document.getElementById("dropPlaceholder")) {
          document.getElementById("dropPlaceholder").remove();
        }
        let liElements = Array.from(document.querySelectorAll("#itemList li:not(.dragging):not(#dropPlaceholder)"));
        let dropIndex = liElements.length;
        for (let i = 0; i < liElements.length; i++) {
          let rect = liElements[i].getBoundingClientRect();
          if (touch.clientY < rect.top + rect.height / 2) {
            dropIndex = i;
            break;
          }
        }
        const items = getItems();
        const [movedItem] = items.splice(mobileDraggingIndex, 1);
        items.splice(dropIndex, 0, movedItem);
        saveItems(items);
        renderItems();
        mobileDraggingIndex = null;
      }
    }
    function updateDragPlaceholder(e) {
      if (mobileDraggingIndex === null) return;
      let touch = e.touches[0];
      let liElements = Array.from(document.querySelectorAll("#itemList li:not(.dragging):not(#dropPlaceholder)"));
      let dropIndex = liElements.length;
      for (let i = 0; i < liElements.length; i++) {
        let rect = liElements[i].getBoundingClientRect();
        if (touch.clientY < rect.top + rect.height / 2) {
          dropIndex = i;
          break;
        }
      }
      if (!dropPlaceholderEl) {
        dropPlaceholderEl = document.createElement("li");
        dropPlaceholderEl.id = "dropPlaceholder";
        dropPlaceholderEl.style.height = "40px";
        dropPlaceholderEl.style.background = "#f9f9f9";
        dropPlaceholderEl.style.border = "2px dashed #aaa";
        dropPlaceholderEl.style.margin = "4px 0";
        dropPlaceholderEl.style.display = "flex";
        dropPlaceholderEl.style.alignItems = "center";
        dropPlaceholderEl.style.justifyContent = "center";
        dropPlaceholderEl.style.fontStyle = "italic";
      }
      const items = getItems();
      if (items[mobileDraggingIndex]) {
        dropPlaceholderEl.textContent = items[mobileDraggingIndex].text;
      }
      const itemList = document.getElementById("itemList");
      const existingPlaceholder = document.getElementById("dropPlaceholder");
      if (existingPlaceholder) existingPlaceholder.remove();
      if (dropIndex >= itemList.children.length) {
        itemList.appendChild(dropPlaceholderEl);
      } else {
        itemList.insertBefore(dropPlaceholderEl, itemList.children[dropIndex]);
      }
    }

    // ---------------------------
    // Global flick detection on the list container (for adding items when tapping outside any li)
    // ---------------------------
    const itemListContainer = document.getElementById("itemList");
    itemListContainer.addEventListener("touchstart", function(e) {
      if (e.target === this) {
        this.dataset.startX = e.touches[0].clientX;
        this.dataset.startY = e.touches[0].clientY;
        this.dataset.touchStartTime = Date.now();
      }
    });
    itemListContainer.addEventListener("touchend", function(e) {
      if (e.target === this) {
        const currentTime = Date.now();
        const startX = parseFloat(this.dataset.startX);
        const elapsed = currentTime - parseInt(this.dataset.touchStartTime);
        const deltaX = e.changedTouches[0].clientX - startX;
        if (deltaX > 50 && elapsed < 300) {
          const touchY = e.changedTouches[0].clientY;
          const index = getInsertionIndexFromY(touchY);
          insertNewItem(index);
        }
      }
    });
    // Compute insertion index based on Y coordinate.
    function getInsertionIndexFromY(touchY) {
      const liElements = Array.from(document.querySelectorAll("#itemList li"));
      if (liElements.length === 0) return 0;
      let closestIndex = 0;
      let minDiff = Infinity;
      liElements.forEach((li, i) => {
        const rect = li.getBoundingClientRect();
        const centerY = rect.top + rect.height / 2;
        const diff = Math.abs(touchY - centerY);
        if (diff < minDiff) {
          minDiff = diff;
          closestIndex = i;
        }
      });
      const rect = liElements[closestIndex].getBoundingClientRect();
      const centerY = rect.top + rect.height / 2;
      return touchY > centerY ? closestIndex + 1 : closestIndex;
    }

    // ---------------------------
    // Render Items – attach touch/double-tap and flick listeners on each li.
    // ---------------------------
    function renderItems() {
      const itemList = document.getElementById("itemList");
      itemList.innerHTML = "";
      const items = getItems();
      items.forEach((item, index) => {
        const li = document.createElement("li");
        li.draggable = true;
        li.ondragstart = (e) => handleDragStart(e, index);
        li.ondragover = handleDragOver;
        li.ondrop = (e) => handleDrop(e, index);
        li.ondragend = handleDragEnd;
        li.style.background = item.checked ? "#d0eaff" : "#fff";

        // Create the content container (checkbox and label)
        const contentDiv = document.createElement("div");
        contentDiv.className = "item-content";
        const checkbox = document.createElement("input");
        checkbox.type = "checkbox";
        checkbox.checked = item.checked;
        checkbox.onclick = (e) => {
          e.stopPropagation();
          toggleItem(index);
        };
        const span = document.createElement("span");
        span.className = "item-text";
        span.textContent = item.text;
        contentDiv.appendChild(checkbox);
        contentDiv.appendChild(span);
        li.appendChild(contentDiv);

        // Drag-handle with its own touch events
        const dragHandle = document.createElement("span");
        dragHandle.className = "drag-handle";
        dragHandle.innerText = "≡";
        dragHandle.addEventListener("touchstart", (e) => handleDragTouchStart(e, index));
        dragHandle.addEventListener("touchend", (e) => handleDragTouchEnd(e, index));
        dragHandle.addEventListener("touchmove", (e) => updateDragPlaceholder(e));
        li.appendChild(dragHandle);

        // Attach touch listeners for the entire row.
        li.addEventListener("touchstart", function(e) {
          this.dataset.startX = e.touches[0].clientX;
          this.dataset.startY = e.touches[0].clientY;
          this.dataset.touchStartTime = Date.now();
        });
        li.addEventListener("touchend", function(e) {
          const currentTime = Date.now();
          const startX = parseFloat(this.dataset.startX || 0);
          const startY = parseFloat(this.dataset.startY || 0);
          const touch = e.changedTouches[0];
          const elapsed = currentTime - parseInt(this.dataset.touchStartTime || currentTime);
          const deltaX = touch.clientX - startX;
          const deltaY = touch.clientY - startY;
          // If double-tap is detected (minimal movement within 300ms), start editing.
          if (this.dataset.lastTap && (currentTime - parseInt(this.dataset.lastTap)) < 300 &&
              Math.abs(deltaX) < 10 && Math.abs(deltaY) < 10) {
            editItem(index, this.querySelector(".item-text"));
            this.dataset.lastTap = "";
            return;
          } else {
            this.dataset.lastTap = currentTime;
          }
          // Flick left to delete.
          if (deltaX < -50 && elapsed < 300) {
            showDeleteConfirm(index);
            return;
          }
          // Flick right to add.
          if (deltaX > 50 && elapsed < 300) {
            insertNewItem(index + 1);
            return;
          }
        });
        li.ondblclick = function(e) {
          editItem(index, this.querySelector(".item-text"));
        };

        itemList.appendChild(li);
      });
      // Append a full-width pale grey footer bar.
      const footer = document.createElement("li");
      footer.className = "footer-bar";
      footer.style.border = "none";
      footer.innerText = "LISTER 🐱";
      itemList.appendChild(footer);
    }

    // ---------------------------
    // List title events: double-tap (or double-click) to edit the title, long-press to delete list.
    // ---------------------------
    const listTitle = document.getElementById("listTitle");
    listTitle.addEventListener("touchstart", function (e) {
      e.preventDefault();
      listDeleteTimer = setTimeout(() => {
        deleteList();
      }, 3000);
    });
    listTitle.addEventListener("touchend", function (e) {
      e.preventDefault();
      const currentTime = Date.now();
      if (this.dataset.lastTap && (currentTime - parseInt(this.dataset.lastTap)) < 300) {
        clearTimeout(listDeleteTimer);
        editListTitle();
        this.dataset.lastTap = "";
      } else {
        this.dataset.lastTap = currentTime;
      }
      clearTimeout(listDeleteTimer);
    });
    listTitle.ondblclick = (e) => {
      e.stopPropagation();
      editListTitle();
    };
  </script>
</body>
</html>
